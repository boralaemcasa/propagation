# start with octonion_product.py and simmulate CCCHHHHOOHHCC[R]

from mpmath import *
import random
import numpy as np

def power(x, y):
   if (y / 2 == mp.floor(y / 2)) and (mp.im(x) == 0) and (mp.re(x) < 0):
      return mp.exp(y * mp.ln(-x))
   else:
      return mp.exp(y * mp.ln(x))

def ID(n):
   M = mp.zeros(n, 1)
   M[0] = 1
   return M

def product(x, y, M, n):
   res = mp.zeros(n, 1)
   for k in range (0, n):
      z = mp.zeros(n, n)
      for i in range (0, n):
         for j in range (0, n):
            z[i, j] = M[i, j, k]
      p = x.T * z * y
      res[k] = p[0]
   return res

def demo(n, M):
   u = mp.zeros(n, 1)
   v = mp.zeros(n, 1)
   w = mp.zeros(n, 1)
   for i in range (0, n):
     u[i] = random.randrange(120)/10
     if random.randrange(2) == 0:
        u[i] = - u[i]
     v[i] = random.randrange(120)/10
     if random.randrange(2) == 0:
        v[i] = - v[i]
     w[i] = random.randrange(120)/10
     if random.randrange(2) == 0:
        w[i] = - w[i]
   print("")
   print("n =", n)
   print("u =", u.T)
   print("v =", v.T)
   print("w =", w.T)
   z1 = product(u, v, M, n)
   print("uv =", z1.T)
   z1 = product(z1, w, M, n)
   z2 = product(u, product(v, w, M, n), M, n)
   z3 = z2 - z1
   print("(uv)w - u(vw) =", z3.T)
   print("")
   print("|u| =", fabs_oct(n, u))
   tmp = inverse_oct(n, u)
   print("1/u =", transpose(tmp))
   print("u * 1/u = ", transpose(product(u, tmp, M, n)))
   print("1/u * u = ", transpose(product(tmp, u, M, n)))
   return

def transpose(x):
   return x.T

def inverse_oct(n, z):
   # 1/z = bar(z) / |z|^2
   bar = mp.zeros(n, 1)
   bar[0] = z[0]
   r = power(z[0], 2)
   for i in range (1, n):
      bar[i] = - z[i]
      r = r + power(z[i], 2)
   return bar/r

def fabs_oct(n, z):
   r = 0
   for i in range (0, n):
      r = r + power(z[i], 2)
   return mp.sqrt(r)

mp.dps = 40
lista = list()
while True:
   if len(lista) < 2:
      x = np.random.randint(1,4)
   else:
      x = np.random.randint(0,4)
   if x == 0:
      break
   lista.append(2**x)
print(lista)
x = np.zeros(lista)
n = len(lista)
v = np.zeros(n, int)
contador = 1
while contador > 0:
   for i in range(0, n):
      v[i] = np.random.randint(0, lista[i])
   a = x
   for i in range(0, n):
      if i == n - 1:
         a[v[i]] = mp.rand()
      a = a[v[i]]   
   contador = x[np.where(x == 0)].shape[0]
print(x)
print(lista)
exit()

mp.dps = 10
n = 2
M = np.zeros((n, n, n))
M[0, 0, 0], M[1, 1, 0], M[0, 1, 1], M[1, 0, 1] = 1, -1, 1, 1
# (a + bi)(x + yi) = (ab - xy, ay + bx) = ((a,b)^T M_1 (x,y), (a,b)^T M_2 (x,y))
demo(n, M)

n = 4
M = np.zeros((n, n, n))
M[0, 0, 0], M[1, 1, 0], M[2, 2, 0], M[3, 3, 0] = 1, -1, -1, -1
M[0, 1, 1], M[1, 0, 1], M[2, 3, 1], M[3, 2, 1] = 1,  1,  1, -1
M[0, 2, 2], M[1, 3, 2], M[2, 0, 2], M[3, 1, 2] = 1, -1,  1,  1
M[0, 3, 3], M[1, 2, 3], M[2, 1, 3], M[3, 0, 3] = 1,  1, -1,  1
# (a + bi + cj + dk)(x + yi + zj + wk) = ax - by - cz - dw + i(ay + bx + cw - dz)
#                                   + j(az - bw + cx + dy) + k(aw + bz - cy + dx)
demo(n, M)

n = 8
M = np.zeros((n, n, n))
M[0,0,0], M[1,1,0], M[2,2,0], M[3,3,0], M[4,4,0], M[5,5,0], M[6,6,0], M[7,7,0] =  1, -1, -1, -1, -1, -1, -1, -1
M[0,1,1], M[1,0,1], M[2,3,1], M[3,2,1], M[4,5,1], M[5,4,1], M[6,7,1], M[7,6,1] =  1,  1,  1, -1,  1, -1, -1,  1
M[0,2,2], M[1,3,2], M[2,0,2], M[3,1,2], M[4,6,2], M[5,7,2], M[6,4,2], M[7,5,2] =  1, -1,  1,  1,  1,  1, -1, -1
M[0,3,3], M[1,2,3], M[2,1,3], M[3,0,3], M[4,7,3], M[5,6,3], M[6,5,3], M[7,4,3] =  1,  1, -1,  1,  1, -1,  1, -1
M[0,4,4], M[1,5,4], M[2,6,4], M[3,7,4], M[4,0,4], M[5,1,4], M[6,2,4], M[7,3,4] =  1, -1, -1, -1,  1,  1,  1,  1
M[0,5,5], M[1,4,5], M[2,7,5], M[3,6,5], M[4,1,5], M[5,0,5], M[6,3,5], M[7,2,5] =  1,  1, -1,  1, -1,  1, -1,  1
M[0,6,6], M[1,7,6], M[2,4,6], M[3,5,6], M[4,2,6], M[5,3,6], M[6,0,6], M[7,1,6] =  1,  1,  1, -1, -1,  1,  1, -1
M[0,7,7], M[1,6,7], M[2,5,7], M[3,4,7], M[4,3,7], M[5,2,7], M[6,1,7], M[7,0,7] =  1, -1,  1,  1, -1, -1,  1,  1

demo(n, M)

T = mp.zeros(n, n)
Id = mp.zeros(n, n)
v = matrix([4,12,20,28,44,52,68,659])
for k in range (0, n):
   e = mp.zeros(n, 1)
   e[k] = 1 # canonical
   w = product(v, e, M, n)
   for i in range (0, n):
      T[i, k] = w[i]
      if i == k:
         Id[i, k] = 1
print("Ortogonal:")
print(T)
print("Good product. T * Transpose = k * Id:")
print(T * T.T - 444889 * Id)

n = 16
M = np.zeros((n, n, n))                                                                                                                                                      #  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15
M[0,0,0],  M[1,1,0],  M[2,2,0],  M[3,3,0],  M[4,4,0],  M[5,5,0],  M[6,6,0],  M[7,7,0],  M[8,8,0], M[9,9,0], M[10,10,0],M[11,11,0],M[12,12,0],M[13,13,0],M[14,14,0],M[15,15,0] = 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
M[0,1,1],  M[1,0,1],  M[2,3,1],  M[3,2,1],  M[4,5,1],  M[5,4,1],  M[6,7,1],  M[7,6,1],  M[8,9,1], M[9,8,1], M[10,11,1],M[11,10,1],M[12,13,1],M[13,12,1],M[14,15,1],M[15,14,1] = 1,+1,+1,-1,+1,-1,-1,+1,+1,-1,-1,+1,-1,+1,+1,-1
M[0,2,2],  M[1,3,2],  M[2,0,2],  M[3,1,2],  M[4,6,2],  M[5,7,2],  M[6,4,2],  M[7,5,2],  M[8,10,2],M[9,11,2],M[10,8,2], M[11,9,2], M[12,14,2],M[13,15,2],M[14,12,2],M[15,13,2] = 1,-1,+1,+1,+1,+1,-1,-1,+1,+1,-1,-1,-1,-1,+1,+1
M[0,3,3],  M[1,2,3],  M[2,1,3],  M[3,0,3],  M[4,7,3],  M[5,6,3],  M[6,5,3],  M[7,4,3],  M[8,11,3],M[9,10,3],M[10,9,3], M[11,8,3], M[12,15,3],M[13,14,3],M[14,13,3],M[15,12,3] = 1,+1,-1,+1,+1,-1,+1,-1,+1,-1,+1,-1,-1,+1,-1,+1
M[0,4,4],  M[1,5,4],  M[2,6,4],  M[3,7,4],  M[4,0,4],  M[5,1,4],  M[6,2,4],  M[7,3,4],  M[8,12,4],M[9,13,4],M[10,14,4],M[11,15,4],M[12,8,4], M[13,9,4], M[14,10,4],M[15,11,4] = 1,-1,-1,-1,+1,+1,+1,+1,+1,+1,+1,+1,-1,-1,-1,-1
M[0,5,5],  M[1,4,5],  M[2,7,5],  M[3,6,5],  M[4,1,5],  M[5,0,5],  M[6,3,5],  M[7,2,5],  M[8,13,5],M[9,12,5],M[10,15,5],M[11,14,5],M[12,9,5], M[13,8,5], M[14,11,5],M[15,10,5] = 1,+1,-1,+1,-1,+1,-1,+1,+1,-1,+1,-1,+1,-1,+1,-1
M[0,6,6],  M[1,7,6],  M[2,4,6],  M[3,5,6],  M[4,2,6],  M[5,3,6],  M[6,0,6],  M[7,1,6],  M[8,14,6],M[9,15,6],M[10,12,6],M[11,13,6],M[12,10,6],M[13,11,6],M[14,8,6], M[15,9,6]  = 1,+1,+1,-1,-1,+1,+1,-1,+1,-1,-1,+1,+1,-1,-1,+1
M[0,7,7],  M[1,6,7],  M[2,5,7],  M[3,4,7],  M[4,3,7],  M[5,2,7],  M[6,1,7],  M[7,0,7],  M[8,15,7],M[9,14,7],M[10,13,7],M[11,12,7],M[12,11,7],M[13,10,7],M[14,9,7], M[15,8,7]  = 1,-1,+1,-1,-1,-1,+1,+1,+1,+1,-1,-1,+1,+1,-1,-1
M[0,8,8],  M[1,9,8],  M[2,10,8], M[3,11,8], M[4,12,8], M[5,13,8], M[6,14,8], M[7,15,8], M[8,0,8], M[9,1,8], M[10,2,8], M[11,3,8], M[12,4,8], M[13,5,8], M[14,6,8], M[15,7,8]  = 1,-1,-1,-1,-1,-1,-1,-1,+1,+1,+1,+1,+1,+1,+1,+1
M[0,9,9],  M[1,8,9],  M[2,11,9], M[3,10,9], M[4,13,9], M[5,12,9], M[6,15,9], M[7,14,9], M[8,1,9], M[9,0,9], M[10,3,9], M[11,2,9], M[12,5,9], M[13,4,9], M[14,7,9], M[15,6,9]  = 1,+1,-1,+1,-1,+1,+1,-1,-1,+1,-1,+1,-1,+1,+1,-1
M[0,10,10],M[1,11,10],M[2,8,10], M[3,9,10], M[4,14,10],M[5,15,10],M[6,12,10],M[7,13,10],M[8,2,10],M[9,3,10],M[10,0,10],M[11,1,10],M[12,6,10],M[13,7,10],M[14,4,10],M[15,5,10] = 1,+1,+1,-1,-1,-1,+1,+1,-1,+1,+1,-1,-1,-1,+1,+1
M[0,11,11],M[1,10,11],M[2,9,11], M[3,8,11], M[4,15,11],M[5,14,11],M[6,13,11],M[7,12,11],M[8,3,11],M[9,2,11],M[10,1,11],M[11,0,11],M[12,7,11],M[13,6,11],M[14,5,11],M[15,4,11] = 1,-1,+1,+1,-1,+1,-1,+1,-1,-1,+1,+1,-1,+1,-1,+1
M[0,12,12],M[1,13,12],M[2,14,12],M[3,15,12],M[4,8,12], M[5,9,12], M[6,10,12],M[7,11,12],M[8,4,12],M[9,5,12],M[10,6,12],M[11,7,12],M[12,0,12],M[13,1,12],M[14,2,12],M[15,3,12] = 1,+1,+1,+1,+1,-1,-1,-1,-1,+1,+1,+1,+1,-1,-1,-1
M[0,13,13],M[1,12,13],M[2,15,13],M[3,14,13],M[4,9,13], M[5,8,13], M[6,11,13],M[7,10,13],M[8,5,13],M[9,4,13],M[10,7,13],M[11,6,13],M[12,1,13],M[13,0,13],M[14,3,13],M[15,2,13] = 1,-1,+1,-1,+1,+1,+1,-1,-1,-1,+1,-1,+1,+1,+1,-1
M[0,14,14],M[1,15,14],M[2,12,14],M[3,13,14],M[4,10,14],M[5,11,14],M[6,8,14], M[7,9,14], M[8,6,14],M[9,7,14],M[10,4,14],M[11,5,14],M[12,2,14],M[13,3,14],M[14,0,14],M[15,1,14] = 1,-1,-1,+1,+1,-1,+1,+1,-1,-1,-1,+1,+1,-1,+1,+1
M[0,15,15],M[1,14,15],M[2,13,15],M[3,12,15],M[4,11,15],M[5,10,15],M[6,9,15], M[7,8,15], M[8,7,15],M[9,6,15],M[10,5,15],M[11,4,15],M[12,3,15],M[13,2,15],M[14,1,15],M[15,0,15] = 1,+1,-1,-1,+1,+1,-1,+1,-1,+1,-1,-1,+1,+1,-1,+1

demo(n, M)

T = mp.zeros(n, n)
Id = mp.zeros(n, n)
v = matrix([4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 1236])
for k in range (0, n):
   e = mp.zeros(n, 1)
   e[k] = 1 # canonical
   w = product(v, e, M, n)
   for i in range (0, n):
      T[i, k] = w[i]
      if i == k:
         Id[i, k] = 1
print("Ortogonal:")
print(T)
print("Bad product. T * Transpose != k * Id:")
print(T * T.T - 1547536 * Id)

n = 32 # 'Show must go on!

# Release 0.1 from 2024/Sep/15
# Vinicius Claudino Ferraz @ Santa Luzia, MG, Brazil
# Out of charity, there is no salvation at all.
# With charity, there is Evolution.
